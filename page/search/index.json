[{"content":"简介 本次实验平台为野火征途mini开发板，用到的外设有按键、LED灯数码管、环境光（ALS）+距离（PS）传感器芯片。\nAP3216C是一款环境光、距离传感器芯片，其接口为IIC接口，FPGA通过IIC接口可以配置工作模式、读取环境光、距离数据。\n系统框图 系统模块连接如下：\nkey_filter模块实现按键消抖功能，mode_reg是1bit寄存器，检测到按键脉冲则翻转，mode会通过led显示，ALS_PS_driver模块负责通过IIC总线驱动AP3216C芯片，其内部有一个状态机和一个IIC驱动模块。\n当mode为0时，读取环境光的16bit的二进制数据，通过一个16bit的二进制转bcd码模块将二进制数据转化为bcd码，最后通过数码管驱动模块显示在开发板的数码管上。当mode为1时，读取、显示的则是距离数据。\n接下来主要介绍ALS_PS_driver模块，其他模块就不介绍了\n环境光、距离传感器驱动模块 ALS_PS_driver模块内部的状态机如下\n根据数据手册，上电200ms后，进入CONFIG状态，配置芯片工作模式为环境光+距离传感器都激活。\n配置好工作模式后，该传感器芯片会将模拟信号转化为数字信号，供我们用IIC接口读取，这个过程需要一定时间，根据数据手册，距离数据转化需要12.5ms，环境光数据转化需要100ms，总共需要112.5ms，每次读取间隔大于112.5ms即可，同时为了防止数据变化太快不方便观察，本次实验设定读取间隔为200ms。\n进入DELAY延时状态，当mode为0时，进入环境光数据读取循环，每200ms读取一次环境光数据，当mode为1时，进入距离数据读取循环，每200ms读取一次距离数据。\n代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 module ALS_PS_driver( input clk, input rst_n, input mode, output reg [15:0] ALS_data, output reg [9:0] PS_data, // iic output scl, inout sda ); //------------signals-------------- // 状态机信号 localparam INIT = 4\u0026#39;h0, // 上电延时200ms CONFIG = 4\u0026#39;h1, // 模式配置 DELAY = 4\u0026#39;h2, // 数据转化等待200ms IIC_READ_ALS_L = 4\u0026#39;h3, // 读取ALS低8位 IIC_WAIT_1 = 4\u0026#39;h4, // 等待ALS低8位读取完成 IIC_READ_ALS_H = 4\u0026#39;h5, // 读取ALS高8位 IIC_READ_PS_L = 4\u0026#39;h6, // 读取PS低4位 IIC_WAIT_2 = 4\u0026#39;h7, // 等待PS低4位读取完成 IIC_READ_PS_H = 4\u0026#39;h8; // 读取PS高6位 reg [3:0] state; // 200ms延时计数器 reg [23:0] cnt; wire cnt_end = (cnt == 24\u0026#39;d10_000_000); // iic读写信号 reg rd_req; reg wr_req; reg [7:0] addr; reg [7:0] wr_data; wire rd_valid; wire [7:0] rd_data; //------------function------------- // 200ms计数器 always @(posedge clk, negedge rst_n) begin if(!rst_n) cnt \u0026lt;= 0; else if(state == INIT || state == DELAY) cnt \u0026lt;= cnt_end ? 24\u0026#39;d0 : (cnt + 24\u0026#39;d1); end // 状态机 always @(posedge clk, negedge rst_n) begin if(!rst_n) state \u0026lt;= INIT; else begin case(state) INIT : state \u0026lt;= cnt_end ? CONFIG : INIT; CONFIG : state \u0026lt;= DELAY; DELAY : state \u0026lt;= cnt_end ? (mode ? IIC_READ_PS_L : IIC_READ_ALS_L) : DELAY; IIC_READ_ALS_L: state \u0026lt;= IIC_WAIT_1; IIC_WAIT_1 : state \u0026lt;= rd_valid ? IIC_READ_ALS_H : IIC_WAIT_1; IIC_READ_ALS_H: state \u0026lt;= DELAY; IIC_READ_PS_L : state \u0026lt;= IIC_WAIT_2; IIC_WAIT_2 : state \u0026lt;= rd_valid ? IIC_READ_PS_H : IIC_WAIT_2; IIC_READ_PS_H : state \u0026lt;= DELAY; default : state \u0026lt;= INIT; endcase end end // iic读写信号 always @(*) begin case(state) CONFIG: begin rd_req = 1\u0026#39;b0; wr_req = 1\u0026#39;b1; addr = 8\u0026#39;h00; wr_data = 8\u0026#39;h03; end IIC_READ_ALS_L: begin rd_req = 1\u0026#39;b1; wr_req = 1\u0026#39;b0; addr = 8\u0026#39;h0c; wr_data = 8\u0026#39;h00; end IIC_READ_ALS_H: begin rd_req = 1\u0026#39;b1; wr_req = 1\u0026#39;b0; addr = 8\u0026#39;h0d; wr_data = 8\u0026#39;h00; end IIC_READ_PS_L: begin rd_req = 1\u0026#39;b1; wr_req = 1\u0026#39;b0; addr = 8\u0026#39;h0e; wr_data = 8\u0026#39;h00; end IIC_READ_PS_H: begin rd_req = 1\u0026#39;b1; wr_req = 1\u0026#39;b0; addr = 8\u0026#39;h0f; wr_data = 8\u0026#39;h00; end default : begin rd_req = 1\u0026#39;b0; wr_req = 1\u0026#39;b0; addr = 8\u0026#39;h00; wr_data = 8\u0026#39;h00; end endcase end // 读取ALS数据到寄存器 always @(posedge clk, negedge rst_n) begin if(!rst_n) ALS_data \u0026lt;= 0; else if(~mode) begin if(rd_valid) begin if(state == IIC_WAIT_1) ALS_data[7:0] \u0026lt;= rd_data; else ALS_data[15:8] \u0026lt;= rd_data; end end end // 读取PS数据到寄存器 always @(posedge clk, negedge rst_n) begin if(!rst_n) PS_data \u0026lt;= 0; else if(mode) begin if(rd_valid) begin if(state == IIC_WAIT_2) PS_data[3:0] \u0026lt;= rd_data[3:0]; else PS_data[9:4] \u0026lt;= rd_data[5:0]; end end end // iic驱动模块 iic_driver #( .ADDR_WIDTH (1), .DEV_ADDR (7\u0026#39;b0011110) ) inst_iic_driver ( .clk (clk), .rst_n (rst_n), .rd_req (rd_req), .wr_req (wr_req), .addr ({8\u0026#39;h00, addr}), .wr_data (wr_data), .rd_valid (rd_valid), .rd_data (rd_data), .scl (scl), .sda (sda) ); endmodule IIC驱动模块 IIC驱动模块不详细介绍了。。。这里给出代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 // ----------------------------------------------------------------------------- // iic驱动，支持400khz，支持地址位宽1字节、2字节，支持单字节读写 // ----------------------------------------------------------------------------- module iic_driver #( // 寄存器地址宽度 parameter ADDR_WIDTH = 2, // 野火开发板EEPROM设备地址为0x53，1010011，这里作为默认地址 parameter DEV_ADDR = 7\u0026#39;b1010011 ) ( input clk, input rst_n, // host side input rd_req, input wr_req, input [15:0] addr, input [7:0] wr_data, output reg rd_valid, output reg [7:0] rd_data, // iic side output reg scl, inout sda ); //-----------------------------------信号声明----------------------------------- // 由于写法问题，SCL频率默认400k，不支持100k和1M localparam SCL_FREQ = 400_000; wire [7:0] DEV_ADDR_W = {DEV_ADDR, 1\u0026#39;b0};// 7bit设备地址 + 1bit写命令(低电平) wire [7:0] DEV_ADDR_R = {DEV_ADDR, 1\u0026#39;b1};// 7bit设备地址 + 1bit读命令(高电平) // 状态机，一共16个状态 reg [3:0] state, next; localparam IDLE = 0, // 空闲 START1 = 1, // 起始位1 DEV_W = 2, // 7bit设备地址 + 1bit写命令(低电平) ACK1 = 3, // 设备地址应答 ADDR_H = 4, // 地址高字节 ACK2 = 5, // 地址高字节应答 ADDR_L = 6, // 地址低字节 ACK3 = 7, // 地址低字节应答 WR_DATA = 8, // 写数据 ACK4 = 9, // 写数据应答 START2 = 10, // 起始位2 DEV_R = 11, // 7bit设备地址 + 1bit读命令(高电平) ACK5 = 12, // 设备地址应答 RD_DATA = 13, // 读数据 NO_ACK = 14, // 无应答 STOP = 15; // 停止位 // 读写状态寄存，0为写，1为读 reg is_read; // wr_data寄存 reg [7:0] wr_data_r; // addr寄存 reg [7:0] addr_h, addr_l; // 读数据寄存器 reg [7:0] rd_data_r; // 应答信号寄存 reg ack_r; // scl计数器，400khz则为125时钟周期，但125不能被4整除，所以选择128，产生的scl频率约为390khz reg [6:0] scl_cnt; // bit计数器 reg [2:0] bit_cnt; // 内部sda reg sda_r; // sda三态门输出使能 wire sda_oe; // sda三态门 assign sda = sda_oe ? sda_r : 1\u0026#39;bz; // scl计数器满，127，即7\u0026#39;b1111111 wire scl_cnt_end = \u0026amp;scl_cnt; // 1字节结束，当scl_cnt == 7\u0026#39;b1111111 且 bit_cnt == 3\u0026#39;b111时，表示1byte结束 wire byte_end = scl_cnt_end \u0026amp; (\u0026amp;bit_cnt); //---------------------------------输入信号寄存--------------------------------- // 地址寄存 always @(posedge clk, negedge rst_n) begin if(!rst_n) {addr_h, addr_l} \u0026lt;= 0; else if(state == IDLE \u0026amp;\u0026amp; (rd_req | wr_req)) {addr_h, addr_l} \u0026lt;= addr; end // 写数据寄存 always @(posedge clk, negedge rst_n) begin if(!rst_n) wr_data_r \u0026lt;= 0; else if(state == IDLE \u0026amp; wr_req) wr_data_r \u0026lt;= wr_data; end //----------------------------------------------------------------------------- // 读状态寄存，读优先，不在读状态即为写状态 always @(posedge clk, negedge rst_n) begin if(!rst_n) is_read \u0026lt;= 1\u0026#39;b0; else if(state == IDLE) is_read \u0026lt;= rd_req; end // 状态机 always @(posedge clk, negedge rst_n) begin if(!rst_n) state \u0026lt;= IDLE; else state \u0026lt;= next; end always @(*) begin case(state) IDLE : next = (rd_req | wr_req) ? START1 : IDLE; START1 : next = scl_cnt_end ? DEV_W : START1; DEV_W : next = byte_end ? ACK1 : DEV_W; ACK1 : next = scl_cnt_end ? (~ack_r ? (ADDR_WIDTH == 2 ? ADDR_H : ADDR_L) : IDLE) : ACK1; ADDR_H : next = byte_end ? ACK2 : ADDR_H; ACK2 : next = scl_cnt_end ? (~ack_r ? ADDR_L : IDLE) : ACK2; ADDR_L : next = byte_end ? ACK3 : ADDR_L; ACK3 : next = scl_cnt_end ? (~ack_r ? (is_read ? START2 : WR_DATA) : IDLE) : ACK3; WR_DATA: next = byte_end ? ACK4 : WR_DATA; ACK4 : next = scl_cnt_end ? (~ack_r ? STOP : IDLE) : ACK4; START2 : next = scl_cnt_end ? DEV_R : START2; DEV_R : next = byte_end ? ACK5 : DEV_R; ACK5 : next = scl_cnt_end ? (~ack_r ? RD_DATA : IDLE) : ACK5; RD_DATA: next = byte_end ? NO_ACK : RD_DATA; NO_ACK : next = scl_cnt_end ? STOP : NO_ACK; STOP : next = scl_cnt_end ? IDLE : STOP; default: next = IDLE; endcase end // scl计数器 always @(posedge clk, negedge rst_n) begin if(!rst_n) scl_cnt \u0026lt;= 0; else if(state != IDLE) scl_cnt \u0026lt;= scl_cnt + 7\u0026#39;d1; end // bit计数器 always @(posedge clk, negedge rst_n) begin if(!rst_n) bit_cnt \u0026lt;= 0; else if(state == DEV_W || state == ADDR_H || state == ADDR_L || state == WR_DATA || state == DEV_R || state == RD_DATA) begin if(scl_cnt_end) bit_cnt \u0026lt;= bit_cnt + 3\u0026#39;d1; end end // scl 每个周期持续128系统时钟周期，scl_cnt[6:5]变化规律为00-01-10-11，所以可以用于调整scl电平，保证sda在scl低电平中间进行跳转 always @(*) begin case(state) IDLE : scl = 1\u0026#39;b1; // 与非 1110 // ___ // |_ START1 : scl = ~(scl_cnt[6] \u0026amp; scl_cnt[5]); // 或 0111 // ___ // _| STOP : scl = scl_cnt[6] | scl_cnt[5]; // 异或 0110 // __ // _| |_ default: scl = scl_cnt[6] ^ scl_cnt[5]; endcase end // sda_oe 在应答状态和读数据状态，允许sda输入 assign sda_oe = ~((state == ACK1) || (state == ACK2) || (state == ACK3) || (state == ACK4) || (state == ACK5) || (state == RD_DATA)); // sda_r always @(*) begin case(state) START1, START2: sda_r = ~scl_cnt[6]; // 下降沿 DEV_W : sda_r = DEV_ADDR_W[~bit_cnt]; // 7bit设备地址 + 1bit写命令 ADDR_H : sda_r = addr_h[~bit_cnt]; // 地址高字节 ADDR_L : sda_r = addr_l[~bit_cnt]; // 地址低字节 WR_DATA : sda_r = wr_data_r[~bit_cnt]; // 写数据 DEV_R : sda_r = DEV_ADDR_R[~bit_cnt]; // 7bit设备地址 + 1bit读命令 STOP : sda_r = scl_cnt[6]; // 上升沿 default : sda_r = 1\u0026#39;b1; endcase end // 采样应答信号 always @(posedge clk, negedge rst_n) begin if(!rst_n) ack_r \u0026lt;= 1\u0026#39;b1; else if((state == ACK1) || (state == ACK2) || (state == ACK3) || (state == ACK4) || (state == ACK5)) begin if(scl_cnt == 7\u0026#39;b0111111) // 在scl高电平中间进行采样 ack_r \u0026lt;= sda; end else ack_r \u0026lt;= 1\u0026#39;b1; end // 读数据 always @(posedge clk, negedge rst_n) begin if(!rst_n) rd_data_r \u0026lt;= 0; else if(state == RD_DATA \u0026amp;\u0026amp; scl_cnt == 7\u0026#39;b0111111)// 在scl高电平中间进行采样 rd_data_r \u0026lt;= {rd_data_r[6:0], sda}; end // 输出读数据 always @(posedge clk, negedge rst_n) begin if(!rst_n) begin rd_valid \u0026lt;= 1\u0026#39;b0; rd_data \u0026lt;= 8\u0026#39;h00; end else if(is_read \u0026amp;\u0026amp; state == STOP \u0026amp;\u0026amp; scl_cnt_end) begin rd_valid \u0026lt;= 1\u0026#39;b1; rd_data \u0026lt;= rd_data_r; end else begin rd_valid \u0026lt;= 1\u0026#39;b0; rd_data \u0026lt;= 8\u0026#39;h00; end end endmodule 二进制转bcd码模块 verilog实现加3移位法-二进制转BCD码\n数码管驱动模块 FPGA驱动74HC595实现数码管动态显示\n","date":"2023-06-15T00:00:00Z","permalink":"https://dungeonboy.github.io/post/iic_als_ps/","title":"FPGA实现IIC驱动环境光、距离传感器"},{"content":"Counters Four-bit binary counter 1 2 3 4 5 6 7 8 9 10 11 module top_module ( input clk, input reset, // Synchronous active-high reset output reg [3:0] q); always @(posedge clk) begin if(reset) q \u0026lt;= 0; else q \u0026lt;= q + 1; end endmodule Decade counter 建立一个计数器，从0计数到9\n1 2 3 4 5 6 7 8 9 10 11 12 13 module top_module ( input clk, input reset, // Synchronous active-high reset output reg [3:0] q); always @(posedge clk) begin if(reset) q \u0026lt;= 0; else if(q == 9) q \u0026lt;= 0; else q \u0026lt;= q + 1; end endmodule Decade counter again 建立一个计数器，从1计数到10\n1 2 3 4 5 6 7 8 9 10 11 12 13 module top_module ( input clk, input reset, output reg [3:0] q); always @(posedge clk) begin if(reset) q \u0026lt;= 1; else if(q == 10) q \u0026lt;= 1; else q \u0026lt;= q + 1; end endmodule Slow decade counter 建立一个计数器，从0计数到9，带使能\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 module top_module ( input clk, input slowena, input reset, output reg [3:0] q); always @(posedge clk) begin if(reset) q \u0026lt;= 0; else if(slowena) begin if(q == 9) q \u0026lt;= 0; else q \u0026lt;= q + 1; end end endmodule Counter 1-12 提供一个4bit的计数器，接口如下：\n1 2 3 4 5 6 7 module count4( input clk, input enable, input load, input [3:0] d, output reg [3:0] Q ); 用这个模块实现一个计数器，从1计数到12，并输出上面模块的enable、load、d\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 module top_module ( input clk, input reset, input enable, output [3:0] Q, output c_enable, output c_load, output [3:0] c_d ); // assign c_enable = enable; assign c_load = reset | (Q == 12 \u0026amp; enable); assign c_d = 4\u0026#39;h1; count4 the_counter (clk, c_enable, c_load, c_d, Q); endmodule Counter 1000 提供一个BCD计数器模块，接口如下\n1 2 3 4 5 6 module bcdcount ( input clk, input reset, input enable, output reg [3:0] Q ); 输入1000hz的时钟，使用该模块输出1hz信号，保证每秒该信号只有一个时钟周期高电平，并输出每个BCD计数器的使能\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 module top_module ( input clk, input reset, output OneHertz, output [2:0] c_enable ); // wire [3:0] bcd0, bcd1, bcd2; assign c_enable[0] = 1\u0026#39;b1; assign c_enable[1] = bcd0 == 9; assign c_enable[2] = c_enable[1] \u0026amp; bcd1 == 9; bcdcount counter0 (clk, reset, c_enable[0], bcd0); bcdcount counter1 (clk, reset, c_enable[1], bcd1); bcdcount counter2 (clk, reset, c_enable[2], bcd2); assign OneHertz = c_enable[2] \u0026amp; bcd2 == 9; endmodule 4-digit decimal counter 建立一个四位数的bcd计数器，并输出十位、百位、千位的使能\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 module top_module ( input clk, input reset, // Synchronous active-high reset output [3:1] ena, output [15:0] q); assign ena[1] = q[3:0] == 9; assign ena[2] = ena[1] \u0026amp; q[7:4] == 9; assign ena[3] = ena[2] \u0026amp; q[11:8] == 9; bcd_counter u0(clk, reset, 1\u0026#39;b1, q[3:0]); bcd_counter u1(clk, reset, ena[1], q[7:4]); bcd_counter u2(clk, reset, ena[2], q[11:8]); bcd_counter u3(clk, reset, ena[3], q[15:12]); endmodule module bcd_counter( input clk, input reset, input ena, output reg [3:0] q ); always @(posedge clk) begin if(reset) q \u0026lt;= 0; else if(ena) begin if(q == 9) q \u0026lt;= 0; else q \u0026lt;= q + 1; end end endmodule 12-hour-clock 建立一个12小时制的时钟，带一个am/pm指示器，复位将时钟设定为12:00AM，指示器pm为0时，表示AM，为1时，表示PM。\n注意：11点过后为12:00，而不是0:00\n下面波形展示了从11:59:59AM翻转到12:00:00PM和复位的波形。\n解题思路：\n秒、分的计时范围为00-59，用bcd计数器实现，个位数计数范围为0-9，直接用bcd计数器即可，十位数计数范围0-5，需要在溢出时用reset清零\n时钟的计时范围为01-12，不太好用bcd计数器实现，所以单独写always解决\npm只需在11点跳转到12点时翻转即可\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 module top_module( input clk, input reset, input ena, output reg pm, output [7:0] hh, output [7:0] mm, output [7:0] ss); wire [1:0] h_ena, m_ena, s_ena; assign s_ena[0] = ena; assign s_ena[1] = s_ena[0] \u0026amp; ss[3:0] == 9; assign m_ena[0] = s_ena[1] \u0026amp; ss[7:4] == 5; assign m_ena[1] = m_ena[0] \u0026amp; mm[3:0] == 9; assign h_ena[0] = m_ena[1] \u0026amp; mm[7:4] == 5; assign h_ena[1] = h_ena[0] \u0026amp; (hh == 8\u0026#39;h09 || hh == 8\u0026#39;h12); bcd_counter s0(clk, reset, s_ena[0], ss[3:0]); bcd_counter s1(clk, reset | m_ena[0], s_ena[1], ss[7:4]); bcd_counter m0(clk, reset, m_ena[0], mm[3:0]); bcd_counter m1(clk, reset | h_ena[0], m_ena[1], mm[7:4]); // h0 always @(posedge clk) begin if(reset) hh[3:0] \u0026lt;= 2; else if(h_ena[0]) begin if(hh == 8\u0026#39;h12) hh[3:0] \u0026lt;= 1; else if(hh == 8\u0026#39;h09) hh[3:0] \u0026lt;= 0; else hh[3:0] \u0026lt;= hh[3:0] + 1; end end // h1 always @(posedge clk) begin if(reset) hh[4] \u0026lt;= 1; else if(h_ena[1]) hh[4] \u0026lt;= ~hh[4]; end // pm always @(posedge clk) begin if(reset) pm \u0026lt;= 0; else if(h_ena[0] \u0026amp;\u0026amp; hh == 8\u0026#39;h11) pm \u0026lt;= ~pm; end endmodule module bcd_counter( input clk, input reset, input ena, output reg [3:0] q ); always @(posedge clk) begin if(reset) q \u0026lt;= 0; else if(ena) begin if(q == 9) q \u0026lt;= 0; else q \u0026lt;= q + 1; end end endmodule Shift Registers 4-bit shift register 建立一个4bit的移位寄存器，右移，带异步复位、load、ena\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 module top_module( input clk, input areset, // async active-high reset to zero input load, input ena, input [3:0] data, output reg [3:0] q); always @(posedge clk, posedge areset) begin if(areset) q \u0026lt;= 0; else if(load) q \u0026lt;= data; else if(ena) q \u0026lt;= {1\u0026#39;b0, q[3:1]}; end endmodule Left/right rotator 建立一个循环左移/右移寄存器，带load、移位使能，当ena为2'b01时右移，当ena为2'b10时左移，其他情况不移位\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 module top_module( input clk, input load, input [1:0] ena, input [99:0] data, output reg [99:0] q); always @(posedge clk) begin if(load) q \u0026lt;= data; else if(ena == 2\u0026#39;b01) // right q \u0026lt;= {q[0], q[99:1]}; else if(ena == 2\u0026#39;b10) // left q \u0026lt;= {q[98:0], q[99]}; end endmodule Left/right arithmetic shift by 1 or 8 建立一个64bit的算数移位寄存器，带load，该移位寄存器可以左移、右移1bit或8bit，算数右移时，左侧填充的是符号位，而不是0。左移时和逻辑左移没有区别，移位方向、移位多少是有amount决定的：\n2\u0026rsquo;b00: 左移1bit 2\u0026rsquo;b01: 左移8bit 2\u0026rsquo;b10: 右移1bit 2\u0026rsquo;b11: 右移8bit 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 module top_module( input clk, input load, input ena, input [1:0] amount, input [63:0] data, output reg [63:0] q); always @(posedge clk) begin if(load) q \u0026lt;= data; else if(ena) begin case(amount) 2\u0026#39;b00: q \u0026lt;= {q[62:0], 1\u0026#39;b0}; 2\u0026#39;b01: q \u0026lt;= {q[55:0], 8\u0026#39;h00}; 2\u0026#39;b10: q \u0026lt;= {q[63], q[63:1]}; 2\u0026#39;b11: q \u0026lt;= {{8{q[63]}}, q[63:8]}; endcase end end endmodule 5-bit LFSR LFSR: (linear feedback shift register)，线性反馈移位寄存器，通常有几个异或门来产生移位寄存器的下一个状态。实现如下图所示的5bit位宽LFSR，其在5和3位置处添加了taps(tap即表示该寄存器D端和q[0]进行异或，tap位置从1开始)：\n1 2 3 4 5 6 7 8 9 10 11 12 module top_module( input clk, input reset, // Active-high synchronous reset to 5\u0026#39;h1 output reg [4:0] q ); always @(posedge clk) begin if(reset) q \u0026lt;= 5\u0026#39;h1; else q \u0026lt;= {q[0], q[4], q[3] ^ q[0], q[2:1]}; end endmodule 3-bit LFSR 实现如下电路：\n1 2 3 4 5 6 7 8 9 10 module top_module ( input [2:0] SW, // R input [1:0] KEY, // L and clk output reg [2:0] LEDR); // Q always @(posedge KEY[0]) begin LEDR[0] \u0026lt;= KEY[1] ? SW[0] : LEDR[2]; LEDR[1] \u0026lt;= KEY[1] ? SW[1] : LEDR[0]; LEDR[2] \u0026lt;= KEY[1] ? SW[2] : (LEDR[1] ^ LEDR[2]); end endmodule 32-bit LFSR 实现一个32bit的LFSR，在第32、22、2、1位置添加taps，参考5-bit LFSR题目\n1 2 3 4 5 6 7 8 9 10 11 12 module top_module( input clk, input reset, // Active-high synchronous reset to 32\u0026#39;h1 output reg [31:0] q ); always @(posedge clk) begin if(reset) q \u0026lt;= 32\u0026#39;h1; else q \u0026lt;= {q[0], q[31:23], q[0] ^ q[22], q[21:3], q[0] ^ q[2], q[0] ^ q[1]}; end endmodule Shift register 实现如下电路:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 module top_module ( input clk, input resetn, // synchronous reset input in, output out); reg [3:0] taps; always @(posedge clk) begin if(~resetn) taps \u0026lt;= 0; else taps \u0026lt;= {in, taps[3:1]}; end assign out = taps[0]; endmodule Shift register 如下为n-bit的Shift Register：\n编写一个模块实现上述电路，假设n=4，编写MUXDFF模块，在顶层实例化4个MUXDFF子模块，假设你要在DE2开发板上实现，端口对应如下:\nR to SW clk to KEY[0] E to KEY[1] L to KEY[2] and w to KEY[3] Q to LEDR 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 module top_module ( input [3:0] SW, input [3:0] KEY, output [3:0] LEDR ); // MUXDFF u0(KEY[0], KEY[1], SW[0], KEY[2], LEDR[1], LEDR[0]); MUXDFF u1(KEY[0], KEY[1], SW[1], KEY[2], LEDR[2], LEDR[1]); MUXDFF u2(KEY[0], KEY[1], SW[2], KEY[2], LEDR[3], LEDR[2]); MUXDFF u3(KEY[0], KEY[1], SW[3], KEY[2], KEY[3], LEDR[3]); endmodule module MUXDFF ( input clk, input E, input R, input L, input W, output reg Q ); always @(posedge clk) begin Q \u0026lt;= L ? R : (E ? W : Q); end endmodule ","date":"2023-06-15T00:00:00Z","permalink":"https://dungeonboy.github.io/post/hdlbits_9/","title":"HDLBits笔记9"},{"content":"D flip-flop 1 2 3 4 5 6 7 module top_module ( input clk, input d, output reg q ); always @(posedge clk) q \u0026lt;= d; endmodule D flip-flops 建立一个8bit的D触发器\n1 2 3 4 5 6 7 8 module top_module ( input clk, input [7:0] d, output reg [7:0] q ); always @(posedge clk) q \u0026lt;= d; endmodule DFF with reset 建立一个8bit的D触发器，带同步高电平复位\n1 2 3 4 5 6 7 8 9 10 11 12 module top_module ( input clk, input reset, // Synchronous reset input [7:0] d, output reg [7:0] q ); always @(posedge clk) if(reset) q \u0026lt;= 0; else q \u0026lt;= d; endmodule DFF with reset value 建立一个下降沿触发的8bit的D触发器，带同步高电平复位，复位时，将触发器的值设置为0x34\n1 2 3 4 5 6 7 8 9 10 11 12 module top_module ( input clk, input reset, input [7:0] d, output reg [7:0] q ); always @(negedge clk) if(reset) q \u0026lt;= 8\u0026#39;h34; else q \u0026lt;= d; endmodule DFF with asynchronous reset 建立一个8bit的D触发器，带异步高电平复位\n1 2 3 4 5 6 7 8 9 10 11 12 module top_module ( input clk, input areset, // active high asynchronous reset input [7:0] d, output reg [7:0] q ); always @(posedge clk, posedge areset) if(areset) q \u0026lt;= 0; else q \u0026lt;= d; endmodule DFF with byte enable 建立一个16bit的D触发器，带2bit的字节使能byteena[1:0]，带同步低电平复位\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 module top_module ( input clk, input resetn, input [1:0] byteena, input [15:0] d, output reg [15:0] q ); always @(posedge clk) if(~resetn) q \u0026lt;= 0; else begin if(byteena[1]) q[15:8] \u0026lt;= d[15:8]; if(byteena[0]) q[7:0] \u0026lt;= d[7:0]; end endmodule D latch 1 2 3 4 5 6 module top_module ( input d, input ena, output q); assign q = ena ? d : q; endmodule DFF 建立一个带异步高电平复位的D触发器\n1 2 3 4 5 6 7 8 9 10 11 module top_module ( input clk, input d, input ar, // asynchronous reset output reg q); always @(posedge clk, posedge ar) if(ar) q \u0026lt;= 0; else q \u0026lt;= d; endmodule DFF 建立一个带同步高电平复位的D触发器\n1 2 3 4 5 6 7 8 9 10 11 module top_module ( input clk, input d, input r, // synchronous reset output reg q); always @(posedge clk) if(r) q \u0026lt;= 0; else q \u0026lt;= d; endmodule DFF + gate 实现如下电路\n1 2 3 4 5 6 7 module top_module ( input clk, input in, output reg out); always @(posedge clk) out \u0026lt;= in ^ out; endmodule Mux and DFF 如下电路中，实例化了3个D触发器+选择器模块，实现D触发器+选择器模块\n1 2 3 4 5 6 7 8 9 module top_module ( input clk, input L, input r_in, input q_in, output reg Q); always @(posedge clk) Q \u0026lt;= L ? r_in : q_in; endmodule Mux and DFF 如下电路是n-bit移位寄存器\n实现其中一级，包括D触发器和选择器\n1 2 3 4 5 6 7 8 module top_module ( input clk, input w, R, E, L, output reg Q ); always @(posedge clk) Q \u0026lt;= L ? R : (E ? w : Q); endmodule DFFs and gates 实现如下电路\n1 2 3 4 5 6 7 8 9 10 module top_module ( input clk, input x, output z ); reg [2:0] st = 0; always @(posedge clk) st \u0026lt;= {x ^ st[2], x \u0026amp; ~st[1], x | ~st[0]}; assign z = ~| st; endmodule Create circuit from truth table J K Q 0 0 Qold 0 1 0 1 0 1 1 1 ~Qold 使用DFF和逻辑门建立JK触发器，实现上述真值表\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 module top_module ( input clk, input j, input k, output reg Q); always @(posedge clk) begin if(~j \u0026amp; k) Q \u0026lt;= 0; else if(j \u0026amp; ~k) Q \u0026lt;= 1; else if(j \u0026amp; k) Q \u0026lt;= ~Q; end endmodule Detech an edge 检测8bit输入的上升沿，波形如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 module top_module ( input clk, input [7:0] in, output [7:0] pedge ); reg [7:0] q1, q2; always @(posedge clk) begin q1 \u0026lt;= in; q2 \u0026lt;= q1; end assign pedge = q1 \u0026amp; ~q2; endmodule Detect both edges 检测输入的双边沿，波形如下\n1 2 3 4 5 6 7 8 9 10 11 12 module top_module ( input clk, input [7:0] in, output [7:0] anyedge ); reg [7:0] q1, q2; always @(posedge clk) begin q1 \u0026lt;= in; q2 \u0026lt;= q1; end assign anyedge = q1 ^ q2; endmodule Edge capture register 捕捉32bit输入的下降沿，即当出现下降沿时，输出将变为1并保持，同步高电平复位，波形如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 module top_module ( input clk, input reset, input [31:0] in, output reg [31:0] out ); reg [31:0] q; always @(posedge clk) q \u0026lt;= in; integer i; always @(posedge clk) begin if(reset) out \u0026lt;= 0; else begin for(i = 0; i \u0026lt; 32; i = i + 1) begin if(q[i] \u0026amp; ~in[i]) out[i] \u0026lt;= 1\u0026#39;b1; end end end endmodule Dual-edge triggered flip-flop 实现一个双边沿触发的D触发器，但不要在一个always里面同时使用上升沿和下降沿，这是不可综合的\n波形如下\n1 2 3 4 5 6 7 8 9 10 11 12 module top_module ( input clk, input d, output q ); reg pos, neg; always @(posedge clk) pos \u0026lt;= d; always @(negedge clk) neg \u0026lt;= d; assign q = clk ? pos : neg; endmodule ","date":"2023-06-14T00:00:00Z","permalink":"https://dungeonboy.github.io/post/hdlbits_8/","title":"HDLBits笔记8"},{"content":"Karnaugh Map to Circuit 3-variable 实现如下卡诺图，用sop和pos两种方式\n化简：\n1 2 3 4 5 6 7 8 module top_module( input a, input b, input c, output out ); // sop和pos相同 assign out = a | b | c; endmodule 4-variable 实现如下卡诺图，用sop和pos两种方式\n化简：\n1 2 3 4 5 6 7 8 9 10 module top_module( input a, input b, input c, input d, output out ); assign out = (~b \u0026amp; ~c) | (~a \u0026amp; ~d) | (b \u0026amp; c \u0026amp; d) | (a \u0026amp; c \u0026amp; d); // pos不常用，而且不好用 // assign out = (~a | ~b | c) \u0026amp; (~b | c | ~d) \u0026amp; (~a | ~c | d) \u0026amp; (a | b | ~c | ~d); endmodule 4-variable 实现如下卡诺图\n化简：\n1 2 3 4 5 6 7 8 module top_module( input a, input b, input c, input d, output out ); assign out = a | (~b \u0026amp; c); endmodule 4-variable 实现如下卡诺图\n不难看出，输入有奇数个1时，输出为1，所以是异或\n1 2 3 4 5 6 7 8 module top_module( input a, input b, input c, input d, output out ); assign out = a ^ b ^ c ^ d; endmodule minimum SOP and POS 一个4输入电路，其输入为a,b,c,d，当输入为2、7、15时，输出1，当输入为0、1、4、5、6、9、10、13、14时，输出0，其他情况不考虑，当a,b,c,d为0001时，输入为1。\n根据题意，画出卡诺图如下：\n化简：\n1 2 3 4 5 6 7 8 9 10 11 12 module top_module ( input a, input b, input c, input d, output out_sop, output out_pos ); assign out_sop = (c \u0026amp; d) | (c \u0026amp; ~a \u0026amp; ~b); // pos偷懒 assign out_pos = out_sop; endmodule Karnaugh map 实现如下卡诺图\n化简：\n1 2 3 4 5 module top_module ( input [4:1] x, output f ); assign f = (x[2] \u0026amp; x[4]) | (x[3] \u0026amp; x[4]) | (~x[1] \u0026amp; x[3]); endmodule Karnaugh map 实现如下卡诺图\n化简：\n1 2 3 4 5 module top_module ( input [4:1] x, output f); assign f = (~x[2] \u0026amp; ~x[3] \u0026amp; ~x[4]) | (x[2] \u0026amp; x[3] \u0026amp; x[4]) | (~x[1] \u0026amp; x[3]) | (x[1] \u0026amp; ~x[2] \u0026amp; x[3] \u0026amp; ~x[4]); endmodule K-map implemented with a multiplexer 实现如下电路中的top_module\n1 2 3 4 5 6 7 8 9 10 module top_module ( input c, input d, output [3:0] mux_in ); assign mux_in[0] = c | d; assign mux_in[1] = 1\u0026#39;b0; assign mux_in[2] = ~d; assign mux_in[3] = c \u0026amp; d; endmodule ","date":"2023-06-09T00:00:00Z","permalink":"https://dungeonboy.github.io/post/hdlbits_7/","title":"HDLBits笔记7"},{"content":"Multiplexers 2-to-1 multiplexer 1 2 3 4 5 module top_module( input a, b, sel, output out ); assign out = sel ? b : a; endmodule 2-to-1 bus multiplexer 1 2 3 4 5 6 module top_module( input [99:0] a, b, input sel, output [99:0] out ); assign out = sel ? b : a; endmodule 9-to-1 multiplexer 建立一个16bit位宽的9选1多路选择器，sel=0选择a，以此类推，其他情况输出全1\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 module top_module( input [15:0] a, b, c, d, e, f, g, h, i, input [3:0] sel, output [15:0] out ); always @(*) begin case(sel) 4\u0026#39;h0: out = a; 4\u0026#39;h1: out = b; 4\u0026#39;h2: out = c; 4\u0026#39;h3: out = d; 4\u0026#39;h4: out = e; 4\u0026#39;h5: out = f; 4\u0026#39;h6: out = g; 4\u0026#39;h7: out = h; 4\u0026#39;h8: out = i; default: out = 16\u0026#39;hffff; endcase end endmodule 256-to-1 multiplexer 建立一个256选1多路选择器，输入打包成一个256bit向量形式，sel=0选择in[0]，以此类推\n1 2 3 4 5 6 module top_module( input [255:0] in, input [7:0] sel, output out ); assign out = in[sel]; endmodule 256-to-1 4bit multiplexer 建立一个4bit位宽的256选1多路选择器，输入打包成一个1024bit向量形式，sel=0选择in[3:0]，以此类推\n1 2 3 4 5 6 module top_module( input [1023:0] in, input [7:0] sel, output [3:0] out ); assign out = in[sel*4 +: 4]; endmodule Arithmetic Circuits Half adder 建立一个半加器，没有cin\n1 2 3 4 5 6 module top_module( input a, b, output cout, sum ); assign cout = a \u0026amp; b; assign sum = a ^ b; endmodule Full adder 建立一个全加器，有cin\n1 2 3 4 5 6 module top_module( input a, b, cin, output cout, sum ); assign cout = (a \u0026amp; b) | (b \u0026amp; cin) | (a \u0026amp; cin); assign sum = a ^ b ^ cin; endmodule 3-bit binary adder 实例化3个全加器，建立一个3-bit行波进位加法器\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 module top_module( input [2:0] a, b, input cin, output [2:0] cout, output [2:0] sum ); fadd u1(a[0], b[0], cin, cout[0], sum[0]); fadd u2(a[1], b[1], cout[0], cout[1], sum[1]); fadd u3(a[2], b[2], cout[1], cout[2], sum[2]); endmodule module fadd( input a, b, cin, output cout, sum ); assign cout = (a \u0026amp; b) | (b \u0026amp; cin) | (cin \u0026amp; a); assign sum = a ^ b ^ cin; endmodule Adder 实现如下电路：\n方法一：根据RTL图，实例化4个全加器\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 module top_module ( input [3:0] x, input [3:0] y, output [4:0] sum); wire [2:0] cout; fadd u0(x[0], y[0], 1\u0026#39;b0, cout[0], sum[0]); fadd u1(x[1], y[1], cout[0], cout[1], sum[1]); fadd u2(x[2], y[2], cout[1], cout[2], sum[2]); fadd u3(x[3], y[3], cout[2], sum[4], sum[3]); endmodule module fadd( input a, b, cin, output cout, sum ); assign cout = (a \u0026amp; b) | (b \u0026amp; cin) | (cin \u0026amp; a); assign sum = a ^ b ^ cin; endmodule 方法二：使用+操作符\n1 2 3 4 5 6 7 module top_module ( input [3:0] x, input [3:0] y, output [4:0] sum ); assign sum = x+y; endmodule Signed addition overflow 将两个8-bit的二进制补码a[7:0]和b[7:0]相加产生s[7:0]，并计算是否有符号位溢出\n符号位溢出：两个正数相加得到负数、两个负数相加得到正数\n1 2 3 4 5 6 7 8 9 module top_module ( input [7:0] a, input [7:0] b, output [7:0] s, output overflow ); assign s = a + b; assign overflow = (~a[7] \u0026amp; ~b[7] \u0026amp; s[7]) | (a[7] \u0026amp; b[7] \u0026amp; ~s[7]); endmodule 100-bit binary adder 建立一个100-bit的二进制加法器，将两个100-bit的数和cin相加得到100-bit的sum和cout\n1 2 3 4 5 6 7 module top_module( input [99:0] a, b, input cin, output cout, output [99:0] sum ); assign {cout, sum} = a + b + cin; endmodule 4-digit BCD adder 提供一个BCD全加器bcd_fadd，其将两个BCD码和cin相加，输出sum和cout，其模块端口如下：\n1 2 3 4 5 6 module bcd_fadd ( input [3:0] a, input [3:0] b, input cin, output cout, output [3:0] sum ); 实例化4个bcd_fadd来建立一个4位数的BCD行波进位加法器，你的加法器要能将两个4位数的BCD数字(16bit位宽)和一个cin相加得到四位数的sum和cout\n1 2 3 4 5 6 7 8 9 10 11 module top_module ( input [15:0] a, b, input cin, output cout, output [15:0] sum ); wire [2:0] _cout; bcd_fadd u0(a[3:0], b[3:0], cin, _cout[0], sum[3:0]); bcd_fadd u1(a[7:4], b[7:4], _cout[0], _cout[1], sum[7:4]); bcd_fadd u2(a[11:8], b[11:8], _cout[1], _cout[2], sum[11:8]); bcd_fadd u3(a[15:12], b[15:12], _cout[2], cout, sum[15:12]); endmodule ","date":"2023-06-03T00:00:00Z","permalink":"https://dungeonboy.github.io/post/hdlbits_6/","title":"HDLBits笔记6"},{"content":"Wire 实现一个电路完成in和out的连线\n1 2 3 module top_module (input in, output out); assign out = in; endmodule GND 实现一个电路将out连到GND\n1 2 3 module top_module (output out); assign out = 1\u0026#39;b0; endmodule NOR 实现或非门\n1 2 3 4 5 6 module top_module ( input in1, input in2, output out); assign out = ~(in1 | in2); endmodule Another Gate 实现如下电路\n1 2 3 4 5 6 module top_module ( input in1, input in2, output out); assign out = in1 \u0026amp; ~in2; endmodule Two Gates 实现如下电路\n1 2 3 4 5 6 7 module top_module ( input in1, input in2, input in3, output out); assign out = (in1 ^~ in2) ^ in3; endmodule More logic gates 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 module top_module( input a, b, output out_and, output out_or, output out_xor, output out_nand, output out_nor, output out_xnor, output out_anotb ); assign out_and = a \u0026amp; b; assign out_or = a | b; assign out_xor = a ^ b; assign out_nand = ~(a \u0026amp; b); assign out_nor = ~(a | b); assign out_xnor = ~(a ^ b); assign out_anotb = a \u0026amp; ~b; endmodule 7420 chip 1 2 3 4 5 6 7 8 module top_module ( input p1a, p1b, p1c, p1d, output p1y, input p2a, p2b, p2c, p2d, output p2y ); assign p1y = ~(p1a \u0026amp; p1b \u0026amp; p1c \u0026amp; p1d); assign p2y = ~(p2a \u0026amp; p2b \u0026amp; p2c \u0026amp; p2d); endmodule Truth table x3 x2 x1 f 0 0 0 0 0 0 1 0 0 1 0 1 0 1 1 1 1 0 0 0 1 0 1 1 1 1 0 0 1 1 1 1 实现上述真值表\n1 2 3 4 5 6 7 8 module top_module( input x3, input x2, input x1, // three inputs output f // one output ); assign f = (~x1 \u0026amp; x2 \u0026amp; ~x3) | (x1 \u0026amp; x2 \u0026amp; ~x3) | (x1 \u0026amp; ~x2 \u0026amp; x3) | (x1 \u0026amp; x2 \u0026amp; x3); endmodule Two-bit equality 实现一个2bit的等于比较器\n1 2 3 module top_module ( input [1:0] A, input [1:0] B, output z ); assign z = A == B; endmodule Simple circuit A 实现一个电路完成z = (x^y) \u0026amp; x功能\n1 2 3 module top_module (input x, input y, output z); assign z = (x ^ y) \u0026amp; x; endmodule Simple circuit B 实现电路实现如下波形\n1 2 3 module top_module ( input x, input y, output z ); assign z = x ^~ y; endmodule Combine circuits A and B 实现如下电路，其中A为上面的Simple circuit A，B为Simple circuit B\n1 2 3 4 5 6 module top_module (input x, input y, output z); wire z1, z2; assign z1 = x \u0026amp; ~y; assign z2 = x ^~ y; assign z = (z1 | z2) ^ (z1 \u0026amp; z2); endmodule Ring or vibrate 假设你在控制一个手机的铃声和振动，当电话打来(input ring)时，你必须响铃(output ringer = 1)或振动(output motor = 1)，但不能同时响铃和振动，如果手机处于振动模式(input vibrate_mode = 1)，则振动，否则响铃\n1 2 3 4 5 6 7 8 9 module top_module ( input ring, input vibrate_mode, output ringer, // Make sound output motor // Vibrate ); assign ringer = vibrate_mode ? 1\u0026#39;b0 : ring; assign motor = vibrate_mode ? ring : 1\u0026#39;b0; endmodule Thermostat 温度调节器内既有加热器也有制冷器，温度调节器有两个状态：加热模式(mode = 1)、制冷模式(mode = 0)。在加热模式，当太冷时(too_cold = 1)，打开加热器，在制冷模式，当太热时(too_hot = 1)，打开制冷器。不管是打开加热器还是制冷器，都要打卡风扇，同时，用户可以自行打开风扇(fan_on = 1)，即使加热器和制冷器都没打开。\n试着尽可能只用assign语句完成该模块\n1 2 3 4 5 6 7 8 9 10 11 12 13 module top_module ( input too_cold, input too_hot, input mode, input fan_on, output heater, output aircon, output fan ); assign heater = mode ? too_cold : 1\u0026#39;b0; assign aircon = mode ? 1\u0026#39;b0 : too_hot; assign fan = fan_on ? 1\u0026#39;b1 : (heater | aircon); endmodule 3-bit population count 计算3bit输入中有多少个1\n1 2 3 4 5 module top_module( input [2:0] in, output [1:0] out ); assign out = in[2] + in[1] + in[0]; endmodule Gates and vectors 输入4bit信号in，输出out_both、out_any、out_different\nout_both: in的每bit和其左邻如果都为1，则该bit的output为1\n举例：如果in[2]和in[3]为1，则out_both[2]为1，in[3]没有左邻，所以没有out_both[3]\nout_any: in的每bit和其右邻如果有至少一个1，则该bit的output为1\n举例：如果in[2]和in[1]有至少一个1，则out_any[2]为1，in[0]没有右邻，所以没有out_both[0]\nout_different: in的每bit和其左邻如果不同，则该bit的output为1\n举例：如果in[2]和in[3]不同，则out_different[2]为1，MSB的左邻为LSB\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 module top_module( input [3:0] in, output [2:0] out_both, output [3:1] out_any, output [3:0] out_different ); // 方法一：逻辑门+位拼接 assign out_both = {in[3] \u0026amp; in[2], in[2] \u0026amp; in[1], in[1] \u0026amp; in[0]}; assign out_any = {in[3] | in[2], in[2] | in[1], in[1] | in[0]}; assign out_different = {in[0] ^ in[3], in[3] ^ in[2], in[2] ^ in[1], in[1] ^ in[0]}; /* 方法二：位选 assign out_any = in[3:1] | in[2:0]; assign out_both = in[2:0] \u0026amp; in[3:1]; assign out_different = in ^ {in[0], in[3:1]}; */ endmodule Even longer vectors 原理同上Gates and vectors，但输入为100bit位宽\n1 2 3 4 5 6 7 8 9 module top_module( input [99:0] in, output [98:0] out_both, output [99:1] out_any, output [99:0] out_different ); assign out_both = in[99:1] \u0026amp; in[98:0]; assign out_any = in[99:1] | in[98:0]; assign out_different = in ^ {in[0], in[99:1]}; endmodule ","date":"2023-06-02T00:00:00Z","permalink":"https://dungeonboy.github.io/post/hdlbits_5/","title":"HDLBits笔记5"},{"content":"Procedures Always blocks(combinational) 建立一个与门，用assign语句和always语句\n1 2 3 4 5 6 7 8 9 10 11 module top_module( input a, input b, output wire out_assign, output reg out_alwaysblock ); assign out_assign = a \u0026amp; b; always @(*) begin out_alwaysblock = a \u0026amp; b; end endmodule Always blocks(clocked) 建立一个异或门，使用assign语句、组合always语句和时序always语句\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 module top_module( input clk, input a, input b, output wire out_assign, output reg out_always_comb, output reg out_always_ff ); assign out_assign = a ^ b; always @(*) begin out_always_comb = a ^ b; end always @(posedge clk) begin out_always_ff \u0026lt;= a ^ b; end endmodul Always if if语句通常用于创建2选1选择器，等同于三目运算符：assign out = (condition) ? x : y;\n建立一个2选1选择器，如果sel_b1和sel_b2为真，选择b，其他情况选择a，使用assign和always\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 module top_module( input a, input b, input sel_b1, input sel_b2, output wire out_assign, output reg out_always ); assign out_assign = (sel_b1 \u0026amp; sel_b2) ? b : a; always @(*) begin if(sel_b1 \u0026amp; sel_b2) out_always = b; else out_always = a; end endmodule If statement latches 如下代码产生了锁存器，修复代码：\n1 2 3 4 5 6 7 8 9 always @(*) begin if (cpu_overheated) shut_off_computer = 1; end always @(*) begin if (~arrived) keep_driving = ~gas_tank_empty; end 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 module top_module ( input cpu_overheated, output reg shut_off_computer, input arrived, input gas_tank_empty, output reg keep_driving ); // always @(*) begin if (cpu_overheated) shut_off_computer = 1; else shut_off_computer = 0; end always @(*) begin if (~arrived) keep_driving = ~gas_tank_empty; else keep_driving = 0; end endmodule Case statement 用case语句创建一个6选1多路选择器\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 module top_module ( input [2:0] sel, input [3:0] data0, input [3:0] data1, input [3:0] data2, input [3:0] data3, input [3:0] data4, input [3:0] data5, output reg [3:0] out ); always@(*) begin case(sel) 3\u0026#39;b000: out = data0; 3\u0026#39;b001: out = data1; 3\u0026#39;b010: out = data2; 3\u0026#39;b011: out = data3; 3\u0026#39;b100: out = data4; 3\u0026#39;b101: out = data5; default: out = 4\u0026#39;h0; endcase end endmodule Priority encoder 优先编码器输出一个向量中第一个1的位置，建立一个4bit优先编码器，如果输入中没有1，则输出0，\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 module top_module ( input [3:0] in, output reg [1:0] pos ); always @(*) begin case(in) 4\u0026#39;h0 : pos = 2\u0026#39;h0; 4\u0026#39;h1 : pos = 2\u0026#39;h0; 4\u0026#39;h2 : pos = 2\u0026#39;h1; 4\u0026#39;h3 : pos = 2\u0026#39;h0; 4\u0026#39;h4 : pos = 2\u0026#39;h2; 4\u0026#39;h5 : pos = 2\u0026#39;h0; 4\u0026#39;h6 : pos = 2\u0026#39;h1; 4\u0026#39;h7 : pos = 2\u0026#39;h0; 4\u0026#39;h8 : pos = 2\u0026#39;h3; 4\u0026#39;h9 : pos = 2\u0026#39;h0; 4\u0026#39;ha : pos = 2\u0026#39;h1; 4\u0026#39;hb : pos = 2\u0026#39;h0; 4\u0026#39;hc : pos = 2\u0026#39;h2; 4\u0026#39;hd : pos = 2\u0026#39;h0; 4\u0026#39;he : pos = 2\u0026#39;h1; 4\u0026#39;hf : pos = 2\u0026#39;h0; default: pos = 2\u0026#39;h0; endcase end endmodule Priority encoder with casez 建立一个8bit优先编码器，从低位开始，输出第一个1的位置，如果输入全0，则输出0，使用casez语句\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 module top_module ( input [7:0] in, output reg [2:0] pos ); always @(*) begin casez(in) 8\u0026#39;bzzzzzzz1: pos = 3\u0026#39;d0; 8\u0026#39;bzzzzzz10: pos = 3\u0026#39;d1; 8\u0026#39;bzzzzz100: pos = 3\u0026#39;d2; 8\u0026#39;bzzzz1000: pos = 3\u0026#39;d3; 8\u0026#39;bzzz10000: pos = 3\u0026#39;d4; 8\u0026#39;bzz100000: pos = 3\u0026#39;d5; 8\u0026#39;bz1000000: pos = 3\u0026#39;d6; 8\u0026#39;b10000000: pos = 3\u0026#39;d7; default : pos = 3\u0026#39;d0; endcase end endmodule Avoiding latches 假设你在建立一个电路处理PS/2键盘的信号，给定2字节信号，你需要判断被按下的按键是哪个\nScancode[15:0] Arrow key 16\u0026rsquo;he06b left arrow 16\u0026rsquo;he072 down arrow 16\u0026rsquo;he074 right arrow 16\u0026rsquo;he075 up arrow Anything else none 你的电路有1个16bit输入，和4个输出，避免产生锁存器\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 // synthesis verilog_input_version verilog_2001 module top_module ( input [15:0] scancode, output reg left, output reg down, output reg right, output reg up ); // 方法一：case always @(*) begin left = 1\u0026#39;b0; down = 1\u0026#39;b0; right = 1\u0026#39;b0; up = 1\u0026#39;b0; case(scancode) 16\u0026#39;he06b: left = 1\u0026#39;b1; 16\u0026#39;he072: down = 1\u0026#39;b1; 16\u0026#39;he074: right = 1\u0026#39;b1; 16\u0026#39;he075: up = 1\u0026#39;b1; endcase end // 方法二：assign // assign left = scancode == 16\u0026#39;he06b; // assign down = scancode == 16\u0026#39;he072; // assign right = scancode == 16\u0026#39;he074; // assign up = scancode == 16\u0026#39;he075; endmodule More Verilog Features conditional ternary operator 输入4个无符号数，输出最小值，使用条件三元运算符\n1 2 3 4 5 6 7 module top_module ( input [7:0] a, b, c, d, output [7:0] min); wire [7:0] min_of_ab = a \u0026lt; b ? a : b; wire [7:0] min_of_cd = c \u0026lt; d ? c : d; assign min = min_of_ab \u0026lt; min_of_cd ? min_of_ab : min_of_cd; endmodule Reduction operator 奇偶校验常用于传输数据时检测错误，建立一个电路输出8bit数据的奇偶校验位，使用偶校验\n奇校验：若8bit数据中1的个数为偶数，则校验位为1，添加校验位后的9bit数据中1的个数为奇数\n偶校验：若8bit数据中1的个数为奇数，则校验位为1，添加校验位后的9bit数据中1的个数为偶数\n1 2 3 4 5 module top_module ( input [7:0] in, output parity); assign parity = ^ in; endmodule Reduction: Even wider gates 建立一个电路，有100bit输入，输出其与、或、异或\n1 2 3 4 5 6 7 8 9 module top_module( input [99:0] in, output out_and, output out_or, output out_xor ); assign out_and = \u0026amp;in; assign out_or = |in; assign out_xor = ^in; endmodule Combinational for-loop: Vector reversal 2 输入100bit信号，反转其bit顺序输出\n1 2 3 4 5 6 7 8 9 10 11 module top_module( input [99:0] in, output [99:0] out ); generate genvar i; for(i = 0; i \u0026lt; 100; i = i + 1) begin:reversal assign out[i] = in[99-i]; end endgenerate endmodule Combinational for-loop: 255-bit population count 人口计数器，计算一个向量中1的个数，建立一个255位宽的人口计数器\n1 2 3 4 5 6 7 8 9 10 module top_module ( input [254:0] in, output reg [7:0] out ); always @(*) begin out = 0; for (int i=0;i\u0026lt;255;i++) out = out + in[i]; end endmodule Generate for-loop: 100bit binary adder 实例化100个全加器实现一个100bit的行波进位加法器\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 module top_module( input [99:0] a, b, input cin, output [99:0] cout, output [99:0] sum ); // 方法一：genearte-for generate genvar i; for(i = 0; i \u0026lt; 100; i = i + 1) begin:gen fadd ins(a[i], b[i], (i == 0) ? cin : cout[i - 1], cout[i], sum[i]); end endgenerate /* 方法二：实例化数组 fadd ins[99:0](a, b, {cout[98:0], cin}, cout, sum); */ endmodule module fadd( input a, b, cin, output cout, sum ); assign sum = a ^ b ^ cin; assign cout = (a \u0026amp; b) | (b \u0026amp; cin) | (a \u0026amp; cin); endmodule Generate for-loop: 100-digit BCD adder 提供bcd_add模块:\n1 2 3 4 5 6 module bcd_fadd ( input [3:0] a, input [3:0] b, input cin, output cout, output [3:0] sum ); 实例化100个该模块，实现100位数BCD行波进位加法器\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 module top_module( input [399:0] a, b, input cin, output cout, output [399:0] sum ); // 方法一：generate-for wire [99:0] cout_vec; generate genvar i; for(i = 0; i \u0026lt; 100; i = i + 1) begin:gen bcd_fadd ins(a[i*4+3 -: 4], b[i*4+3 -: 4], (i == 0) ? cin : cout_vec[i-1], cout_vec[i], sum[i*4+3 -: 4]); end endgenerate assign cout = cout_vec[99]; /* // 方法二：实例化数组 wire [99:0] cout_vec; bcd_fadd ins[99:0](a, b, {cout_vec[98:0], cin}, cout_vec, sum); assign cout = cout_vec[99]; */ endmodule ","date":"2023-05-27T00:00:00Z","permalink":"https://dungeonboy.github.io/post/hdlbits_4/","title":"HDLBits笔记4"},{"content":"Vectors 建立一个电路，有一个3bit输入，输出这个向量，并将其分割为三个单独的1bit信号输出，电路图如下：\n1 2 3 4 5 6 7 8 9 module top_module ( input wire [2:0] vec, output wire [2:0] outv, output wire o2, output wire o1, output wire o0 ); assign outv = vec; assign {o2, o1, o0} = vec; endmodule Vectors in more detail 建立一个组合电路将16bit输入分为高字节和低字节\n1 2 3 4 5 6 module top_module( input wire [15:0] in, output wire [7:0] out_hi, output wire [7:0] out_lo ); assign {out_hi, out_lo} = in; endmodule Vector part select 一个32bit的向量可以看做4字节，建立一个电路将32bit输入的字节顺序翻转输出，如下：\nAaaaaaaaBbbbbbbbCcccccccDddddddd =\u0026gt; DdddddddCcccccccBbbbbbbbAaaaaaaa\n该操作常用于大小端转换\n1 2 3 4 5 module top_module( input [31:0] in, output [31:0] out ); assign out = {in[7:0], in[15:8], in[23:16], in[31:24]}; endmodule Bitwise operators 建立一个电路，有两个3bit输入，计算二者的位或、逻辑或、取非，将b取非后放入out_not高位，将a取非后放入out_not低位\n1 2 3 4 5 6 7 8 9 10 11 module top_module( input [2:0] a, input [2:0] b, output [2:0] out_or_bitwise, output out_or_logical, output [5:0] out_not ); assign out_or_bitwise = a | b; assign out_or_logical = a || b; assign out_not = ~{b, a}; endmodule Four-input gates 建立一个组合电路，有4个输入：in[3:0]，有3个输出：\nout_and: 四输入与门 out_or：四输入或门 out_xor：四输入异或门 1 2 3 4 5 6 7 8 9 10 module top_module( input [3:0] in, output out_and, output out_or, output out_xor ); assign out_and = \u0026amp;in; assign out_or = |in; assign out_xor = ^in; endmodule Vector concatenation 输入6个5bit向量，一共30bit，将它们拼接在一起，低位补1，凑齐32bit，再输出给4个8bit向量\n1 2 3 4 5 module top_module ( input [4:0] a, b, c, d, e, f, output [7:0] w, x, y, z ); assign {w, x, y, z} = {a, b, c, d, e, f, 2\u0026#39;b11}; endmodule Vector reversal 1 输入8bit向量，将其翻转输出\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 module top_module( input [7:0] in, output [7:0] out ); /* // 方法1：位拼接，只适用于位宽较小情况 assign {out[0],out[1],out[2],out[3],out[4],out[5],out[6],out[7]} = in; // 方法2：for integer i; always @(*) begin\tfor (i=0; i\u0026lt;8; i++) out[i] = in[7-i]; end */ // 方法3：generate-for, 要求for循环的begin-end有命名，此处为reversal genvar i; generate for(i = 0; i \u0026lt; 8; i = i + 1) begin:reversal assign out[i] = in[7-i]; end endgenerate endmodule Replication operator 复制运算符常用于将小位宽的有符号数进行符号位扩展，建立一个电路将8bit有符号数进行符号位扩展\n1 2 3 4 5 module top_module ( input [7:0] in, output [31:0] out ); assign out = {{24{in[7]}},in}; endmodule More repication 输入5个1bit信号a, b, c, d, e，根据下图计算25bit输出\n1 2 3 4 5 module top_module ( input a, b, c, d, e, output [24:0] out ); assign out = {{5{a}}, {5{b}}, {5{c}}, {5{d}}, {5{e}}} ~^ {5{a, b, c, d, e}}; endmodule ","date":"2023-05-26T00:00:00Z","permalink":"https://dungeonboy.github.io/post/hdlbits_2/","title":"HDLBits笔记2"},{"content":"Modules 在顶层模块中实例化模块mod_a，其端口描述：\nmodule mod_a ( input in1, input in2, output out );\n1 2 3 4 5 6 7 8 9 10 module top_module ( input a, input b, output out ); // 按信号名称连线 mod_a u1( .in1(a), .in2(b), .out(out) ); // 按信号位置连线 // mod_a u2(a, b, out); endmodule Connection ports by position 在顶层模块中按信号位置实例化模块mod_a，其端口描述：\nmodule mod_a ( output, output, input, input, input, input );\n1 2 3 4 5 6 7 8 9 10 module top_module ( input a, input b, input c, input d, output out1, output out2 ); mod_a u_1(out1, out2, a, b, c, d); endmodule Connecting ports by name 在顶层模块中按信号名实例化mod_a，其端口描述：\nmodule mod_a ( output out1, output out2, input in1, input in2, input in3, input in4);\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 module top_module ( input a, input b, input c, input d, output out1, output out2 ); mod_a u1( .in1 (a), .in2 (b), .in3 (c), .in4 (d), .out1(out1), .out2(out2) ); endmodule Three modules 提供D触发器模块my_dff，实例化3个D触发器，链式连接它们实现一个3bit移位寄存器\nD触发器my_dff的端口描述：module my_dff ( input clk, input d, output q );\n1 2 3 4 5 6 module top_module ( input clk, input d, output q ); wire q1, q2; my_dff u1(clk, d, q1); my_dff u2(clk, q1, q2); my_dff u3(clk, q2 ,q); endmodule Modules and vectors 提供8位D触发器my_dff8，实例化3个8位D触发器，链式连接它们，实现长度为3的8位移位寄存器，并实现一个4选1多路选择器，选择输出打0、1、2、3拍的输入信号\nmy_dff8的端口描述：my_dff8 ( input clk, input [7:0] d, output [7:0] q );\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 module top_module ( input clk, input [7:0] d, input [1:0] sel, output reg [7:0] q ); wire [7:0] q1, q2, q3; my_dff8 u1(clk, d, q1); my_dff8 u2(clk, q1, q2); my_dff8 u3(clk, q2, q3); always @(*) begin case(sel) 2\u0026#39;b00: q = d; 2\u0026#39;b01: q = q1; 2\u0026#39;b10: q = q2; 2\u0026#39;b11: q = q3; endcase end endmodule Adder 1 提供16位加法器模块add16，实例化2个该模块，实现32位加法器，一个计算低16位，一个计算高16位\nadd16的端口描述：module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 module top_module( input [31:0] a, input [31:0] b, output [31:0] sum ); wire cout; add16 u1( .a (a[15:0]), .b (b[15:0]), .cin (1\u0026#39;b0), .sum (sum[15:0]), .cout(cout) ); add16 u2( .a (a[31:16]), .b (b[31:16]), .cin (cout), .sum (sum[31:16]), .cout() ); endmodule Adder 2 编写1位全加器add1，系统会实例化16个1位全加器，实现16位加法器add16，在此基础上，实例化2个16位加法器，实现32位加法器：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 module top_module ( input [31:0] a, input [31:0] b, output [31:0] sum ); wire cout; add16 u1( .a (a[15:0]), .b (b[15:0]), .cin (1\u0026#39;b0), .sum (sum[15:0]), .cout(cout) ); add16 u2( .a (a[31:16]), .b (b[31:16]), .cin (cout), .sum (sum[31:16]), .cout() ); endmodule module add1 ( input a, input b, input cin, output sum, output cout ); assign cout = (a \u0026amp; b) | (b \u0026amp; cin) | (a \u0026amp; cin); assign sum = a ^ b ^ cin; endmodule Carry-select adder 行波进位加法器的缺点是延迟太大，每一个全加器都必须等待前一个全加器的进位产生，这导致加法器延迟大。\n进位选择加法器是对此的一种改进，低16位加法器保持不变，高16位加法器实例化两个，一个假设低16位进位为0，一个假设为1，用2选1选择器选择使用哪个结果，如下图：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 module top_module( input [31:0] a, input [31:0] b, output [31:0] sum ); wire low_cout; wire [15:0] high_sum0, high_sum1, high_sum; add16 low( .a (a[15:0]), .b (b[15:0]), .cin (1\u0026#39;b0), .sum (sum[15:0]), .cout (low_cout) ); add16 high0( .a (a[31:16]), .b (b[31:16]), .cin (1\u0026#39;b0), .sum (high_sum0), .cout () ); add16 high1( .a (a[31:16]), .b (b[31:16]), .cin (1\u0026#39;b1), .sum (high_sum1), .cout () ); assign sum[31:16] = low_cout ? high_sum1 : high_sum0; endmodule Adder-subtractor 选择性的将加法器的一个输入反转，就能从加法器构建加减器，此时进位也为1，等同于反转后+1。一个加减器能够实现两种操作：(a + b + 0)或(a + ~b + 1)，提供16位加法器add16，建立32位加减器。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 module top_module( input [31:0] a, input [31:0] b, input sub, output [31:0] sum ); wire cout; add16 u0( .a (a[15:0]), .b ({16{sub}} ^ b[15:0]),// 异或有选择反相性 .cin (sub), .sum (sum[15:0]), .cout(cout) ); add16 u1( .a (a[31:16]), .b ({16{sub}} ^ b[31:16]), .cin (cout), .sum (sum[31:16]), .cout() ); endmodule ","date":"2023-05-26T00:00:00Z","permalink":"https://dungeonboy.github.io/post/hdlbits_3/","title":"HDLBits笔记3"},{"content":"什么是IEEE754标准 1985年, IEEE754标准问世，提供了以二进制的方式存储十进制浮点数的具体标准。\nIEEE754提供了四种精度规范, 其中最常用的是单精度浮点型 和双精度浮点型 , IEEE754并没有规定float和double表示单精度浮点型和双精度浮点型，但一般提到float、double指的就是单精度、双精度型。\n浮点数的存储方式 32位单精度浮点数 32位浮点数（也叫单精度浮点数、float类型）被划分为三部分：\nsign: 1bit符号位，0表示正数，1表示负数\nexponent: 8bit偏移后的指数位，用于表示以2为底的指数，范围为[-127, 128]\n为了表示方便，指数位有一个固定的偏移量(bias)，用于使指数+偏移量=非负数，在32位浮点数中，偏移量为127，在64位浮点数中，偏移量为1023\n例：如果指数为-127，则该8bit为-127+127=0；如果指数为-10，则该8bit为-10+127=117\n个人理解：8bit二进制数表示范围为[0, 255]，既不想要符号位又想表示负数，所以此处有偏移量概念，即将[0, 255]的表示范围转换为[-127, 128]\nfraction: 23bit尾数位\n以二进制存储十进制浮点数时，首先要把十进制转换为二进制 以20.5为例，二进制为10100.1，将该数转换为二进制指数形式：1.01001 * 2^4，小数点放在左边第一位和第二位中间，且第一位不能为0，这个过程叫规范化(normalized)，则1.01001为尾数，4为偏移前的指数(unbiased exponent)，偏移后的指数(biased exponent)为4+127=131，131的二进制为10000011 隐藏高位1：由于经过规范化后，小数点前必定为1，所以在存储尾数时，可以省略小数点前的1，节约1bit空间，此处只需记录剩余尾数部分01001 低位补零：在隐藏高位后，尾数为01001，只有5bit，其余低位补零即可，则20.5最终的32位浮点数表示为：0100 0001 1010 0100 0000 0000 0000 0000或0x41A40000 已知浮点数表示，求其十进制数，计算方法如图：\n64位双精度浮点数 原理同上\n浮点数的取指范围 维基百科给出的取值范围 下图是维基百科给出的32位和64位浮点数的十进制取指范围：\n32位浮点数的十进制有效数字大约为7位，64位的有效数字大约为16位\n前置概念 normal number、subnormal number IEEE754规定，尾数的隐藏位为1则为normal number（规格数），为0则为subnormal number（非规格数）\n一般来说，尾数隐藏位为1的数为规格数，即正常的数\n当指数位全0时，表示该数为非规格数，即尾数隐藏位为0\nnon-number IEEE754规定指数位全1的数为non-number（特殊数）\n指数位全1时，指数为128，即该数为infinity(无穷)，或NaN(Not a Number)\n计算方法 根据上述概念，讨论浮点数取值范围时，讨论的是normal number取值范围，即不包括指数位全0和全1的特殊情况\n此时的指数位取值范围为[1, 254]，代表的指数范围为[-126, 127]\n尾数隐藏位始终为1，所以尾数表示范围为[1.000...000, 1.111...111]，即十进制的[1, 2)\n则32位浮点数的取值范围为：\n注意开闭区间\n将上式的以2为底换成以10为底，省略掉多余的小数，就得到上方维基百科给出的取值范围\n补充 下图表示32位单精度浮点数取指范围示意图：\n可以看到，normal number的取值范围不包括0以及周围小范围的数\n后续 有待补充~\n","date":"2023-05-25T00:00:00Z","permalink":"https://dungeonboy.github.io/post/ieee754/","title":"IEEE754浮点数标准"},{"content":"Getting Started 输出1\n1 2 3 4 5 module top_module( output one ); assign one = 1\u0026#39;b1; endmodule Output Zero 输出0\n1 2 3 4 5 module top_module( output zero ); assign zero = 1\u0026#39;b0; endmodule Simple wire 建立一个模块将out和in连线\n1 2 3 module top_module( input in, output out ); assign out = in; endmodule Four wires 建立一个三输入四输出模块，其连线如下：\na -\u0026gt; w\nb -\u0026gt; x\nb -\u0026gt; y\nc -\u0026gt; z\n1 2 3 4 5 6 module top_module( input a,b,c, output w,x,y,z ); assign {w,x,y,z} = {a,b,b,c}; endmodule Inverter 建立一个模块实现非门\n1 2 3 4 5 6 module top_module( input in, output out ); assign out = ~in; endmodule AND gate 建立一个模块实现与门\n1 2 3 4 5 6 module top_module( input a, input b, output out ); assign out = a \u0026amp; b; endmodule NOR gate 建立一个模块实现或非门\n1 2 3 4 5 6 7 module top_module( input a, input b, output out ); assign out = ~(a | b); endmodule XNOR gate 建立一个模块实现同或门\n1 2 3 4 5 6 7 module top_module( input a, input b, output out ); assign out = a ~^ b; endmodule Declaring wires 实现如下电路：\n1 2 3 4 5 6 7 8 9 10 11 12 13 module top_module( input a, input b, input c, input d, output out, output out_n ); wire w1 = a \u0026amp; b; wire w2 = c \u0026amp; d; assign out = w1 | w2; assign out_n = ~out; endmodule 7458 chip 创建一个模块实现7458芯片的功能：\n1 2 3 4 5 6 7 8 9 module top_module ( input p1a, p1b, p1c, p1d, p1e, p1f, output p1y, input p2a, p2b, p2c, p2d, output p2y ); assign p1y = (p1a \u0026amp; p1b \u0026amp; p1c) | (p1d \u0026amp; p1e \u0026amp; p1f); assign p2y = (p2a \u0026amp; p2b) | (p2c \u0026amp; p2d); endmodule ","date":"2023-05-24T00:00:00Z","permalink":"https://dungeonboy.github.io/post/hdlbits_1/","title":"HDLBits笔记1"}]